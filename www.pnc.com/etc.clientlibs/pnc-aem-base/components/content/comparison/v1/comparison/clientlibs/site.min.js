const { createApp } = Vue;

const app = createApp({});

app.directive('resize', {
    mounted: function (el, binding) {
        const onResizeCallback = binding.value;
        window.addEventListener('resize', () => {
            const width = document.documentElement.clientWidth;
            onResizeCallback({ width });
        })
    }
});
app.component('DropDown', {
    props: ['pos', 'products', 'hasColumnThree'],
    template: `
    <div class="button cmp-button--comparison" ref="productMenu">
      <button class="cmp-button product-menu-toggle" ref="productMenuButton" :aria-expanded="productMenuToggle ? 'true' : 'false'" @click='productMenuToggle = !productMenuToggle' @keydown.esc="productMenuToggle = false;" @keydown.shift.tab="handleMenuFocusOut">
          <span class="cmp-button__icon cmp-button__icon cmp-button__icon--comparison fal" :class="[productMenuToggle ? 'fa-times' : 'fa-chevron-down']"></span>
          <span class="cmp-button__text visually-hidden">View Product List</span>
      </button>
    </div> 
    <div class="product-menu" v-if="productMenuToggle" ref="productMenuOptions" v-on:focusout="handleMenuFocusOut" @keydown.esc="productMenuToggle = false; $refs.productMenuButton.focus()">
        <p :id="'productMenu'+pos"><strong>Select Another Product</strong></p>
        <ul :aria-labelledby="'productMenu'+pos">
            <li v-for="item in products.all" :key="item.name">
                <button type="button" :class="isSelected(item,pos) ? 'product--selected' : 'product'" :aria-current="isSelected(item,pos) ? 'true' : 'false'" :disabled="isDisabled(item)" :value="item.baseProduct.fragmentId" @click='switchProducts(pos, item)'>{{item.baseProduct.name.plaintext}}</button>
            </li>
        </ul>
    </div>`,
    data() {
        return {
            productMenuToggle: false
        }
    },
    emits: ["changeproduct"],
    methods: {
        productMenuClick(e) {
            if (this.productMenuToggle) {
                let el = this.$refs.productMenu
                let target = e.target;
                if ((el !== target) && !el.contains(target)) {
                    this.productMenuToggle = false
                }
                this.$nextTick(() => {
                    if (this.$refs.productMenuOptions) { this.$refs.productMenuOptions.focus(); }
                });
            }
        },
        handleMenuFocusOut(e) {
            if(!e.relatedTarget?.closest(".product-menu")) {
                this.productMenuToggle = false;
            }
        },
        switchProducts(colNum, item) {
            this.checkForDuplicate(colNum, item);
            const col = 'p' + colNum;
            this.products[col] = item;
            this.$emit("changeproduct", this.products);
            this.$nextTick(() => {
                const tableHeadingId = "productheading" + colNum;
                let headingEl = document.getElementById(tableHeadingId);
                headingEl.focus();
                window.CQ.disclosure.build();
            });
        },
        checkForDuplicate: function (colNum, newProduct) {
            let currentPIDList = [];
            let i = 0;

            // Create list of current Product IDs
            while (this.products.hasOwnProperty("p" + i)) {
                currentPIDList.push(this.products["p" + i]?.baseProduct.fragmentId);
                i++;
            }
            // Test if a duplicate product exists
            if (currentPIDList?.indexOf(newProduct.baseProduct.fragmentId) > -1) {
                // Duplicate ID found. Replace product.
                const duplicateIndex = currentPIDList?.indexOf(newProduct.baseProduct.fragmentId);
                let alternateProduct = this.products.all.find(obj => !currentPIDList.includes(obj?.baseProduct.fragmentId) );
                // alternateProduct is null if there are exactly 3 products. Prevent Null product being set
                if (!alternateProduct) { alternateProduct = this.products["p" + colNum]; }
                this.products["p" + duplicateIndex] = alternateProduct              
            }
        },
        isDisabled(item) {
            for (i = 0; i < 3; i++) {
                if (this.products["p" + i] && this.products["p" + i].baseProduct.fragmentId === item.baseProduct.fragmentId) {
                    if (i === 2 && !this.hasColumnThree) { return false; }
                    return true;
                }
            }
            return false;
        },
        isSelected(item, pos) {
            return this.products["p" + pos].baseProduct.fragmentId === item.baseProduct.fragmentId;
        }
    },
    created() {
        document.addEventListener('click', this.productMenuClick);
    },
    destroyed() {
        document.removeEventListener('click', this.productMenuClick);
    }
});
app.component('LinksRow', {
    props: ['heading', 'products', 'target', 'targetDetails', 'hasColumnThree'],
    template: `
    <th class="visually-hidden" scope="row">{{heading}}</th>
    <td>
      <a v-if="products.p0.baseProduct[target]" :href="products.p0.baseProduct[target]" v-html="products.p0.baseProduct[target + 'Text'].html"><span class="visually-hidden">&nbsp;for {{products.p0.baseProduct.name.plaintext}}</span> <span class="cmp-button__icon fas fa-long-arrow-right"></span></a>
      <span v-else class="visually-hidden">N/A</span>
      <a v-if="products.p0.baseProduct[targetDetails]" :href="products.p0.baseProduct[targetDetails]" v-html="products.p0.baseProduct[targetDetails + 'Text'].html"><span class="visually-hidden">&nbsp;for {{products.p0.baseProduct.name.plaintext}}</span></a>
      <span v-else class="visually-hidden">N/A</span>
    </td>
    
    <td>
      <a v-if="products.p1.baseProduct[target]" :href="products.p1.baseProduct[target]" v-html="products.p1.baseProduct[target + 'Text'].html"><span class="visually-hidden">&nbsp;for {{products.p1.baseProduct.name.plaintext}}</span> <span class="cmp-button__icon fas fa-long-arrow-right"></span></a>
      <span v-else class="visually-hidden">N/A</span>
      <a v-if="products.p1.baseProduct[targetDetails]" :href="products.p1.baseProduct[targetDetails]" v-html="products.p1.baseProduct[targetDetails + 'Text'].html"><span class="visually-hidden">&nbsp;for {{products.p1.baseProduct.name.plaintext}}</span></a>
      <span v-else class="visually-hidden">N/A</span>
    </td>
    <td v-if="hasColumnThree">
      <a v-if="products.p2.baseProduct[target]" :href="products.p2.baseProduct[target]" v-html="products.p2.baseProduct[target + 'Text'].html"><span class="visually-hidden">&nbsp;for {{products.p2.baseProduct.name.plaintext}}</span> <span class="cmp-button__icon fas fa-long-arrow-right"></span></a>
      <span v-else class="visually-hidden">N/A</span>
      <a v-if="products.p2.baseProduct[targetDetails]" :href="products.p2.baseProduct[targetDetails]" v-html="products.p2.baseProduct[targetDetails + 'Text'].html"><span class="visually-hidden">&nbsp;for {{products.p2.baseProduct.name.plaintext}}</span></a>
      <span v-else class="visually-hidden">N/A</span>
    </td>`
});
app.component('comparison', {
    props: ['link-id', 'element-names', 'param-name', 'param-values', 'product-ids', 'product-max', 'query-title'],
    template: `
    <div class="cmp-comparison-menu">
    </div>
    <table v-if="activeModel && products.valid" v-resize="setDimensions" :class="columnClass">
    <tbody v-if="products.p0?.baseProduct.image !== null || products.p1?.baseProduct.image !== null || products.p2?.baseProduct.image !== null">
      <tr aria-hidden="true">
        <th class="visually-hidden" scope="row"><p>Credit Card Image</p></th>
        <td><img v-if="products.p0.baseProduct.image !== null" :src="products.p0.baseProduct.image._path" alt="" /></td>
        <td><img v-if="products.p1.baseProduct.image !== null" :src="products.p1.baseProduct.image._path" alt="" /></td>
        <td v-if="hasColumnThree"><img v-if="products.p2.baseProduct.image !== null" :src="products.p2.baseProduct.image._path" alt="" /></td>
      </tr>
    </tbody>
      <thead>
        <tr>
          <th class="visually-hidden" scope="row">Products</th>
            <th scope="col">
                <div class="prod-selection">
                    <div class="prod-title">
                        <span id="productheading0" tabindex="-1" v-html="products.p0.baseProduct.name.html"></span>
                    </div>
                    <div v-show="showProductMenu" class="prod-list">
                        <DropDown pos="0" v-if="products" :products="products" @changeproduct="products = $event" :hasColumnThree="hasColumnThree" />
                    </div>
                </div>
            </th>
            <th scope="col">
                <div class="prod-selection">
                    <div class="prod-title">
                        <span id="productheading1" tabindex="-1" v-html="products.p1.baseProduct.name.html"></span>
                    </div>
                    <div v-show="showProductMenu" class="prod-list">
                        <DropDown pos="1" v-if="products" :products="products" @changeproduct="products = $event" :hasColumnThree="hasColumnThree" />
                    </div>
                </div>
            </th>
           <th v-if="hasColumnThree" scope="col">
                <div class="prod-selection">
                    <div  class="prod-title">
                        <span id="productheading2" tabindex="-1" v-html="products.p2.baseProduct.name.html"></span>
                    </div>
                    <div v-show="showProductMenu"  class="prod-list">
                        <DropDown pos="2" v-if="products" :products="products" @changeproduct="products = $event" :hasColumnThree="hasColumnThree" />
                    </div>
                </div>
            </th>
        </tr>
        <tr v-show="showProductMenu">
            <th class="visually-hidden" scope="row">Product Menu Options</th>
        </tr>
        <tr v-if="products.p0.baseProduct.ctaPage !== null || products.p0.baseProduct.detailsPage !== null" >
          <LinksRow heading="Next Step" target="ctaPage" targetDetails="detailsPage" :products="products" :hasColumnThree="hasColumnThree" />
        </tr>
      </thead>
      <tbody>      
        <template v-for="(value,name) in products.p0">
          <tr v-if="!name.endsWith('Title') && name!=='_path' && name!=='learnMore' && name!=='baseProduct'">
            <th v-if="products.p0[name + 'Title']" scope="row">{{ products.p0[name + 'Title'].value }}</th>
            <th v-else style="display:none"></th>

            <template v-if="typeof value === 'object' && !Array.isArray(value) && value !== null">
              <td v-html="products.p0[name].html"></td>
              <td v-html="products.p1[name].html"></td>
              <td v-if="hasColumnThree"  v-html="products.p2[name].html"></td>
            </template>
            <template v-else>
              <template v-if="isLink(products.p0[name])">
                <td><a :href="products.p0[name]">{{ products.p0[name + 'Title'].value }}</a></td>
                <td><a :href="products.p1[name]">{{ products.p1[name + 'Title'].value }}</a></td>
                <td v-if="hasColumnThree"><a :href="products.p2[name]">{{ products.p2[name + 'Title'].value }}</a></td>
              </template>
              <template v-else>
                <td>{{ products.p0[name] }}</td>
                <td>{{ products.p1[name] }}</td>
                <td v-if="hasColumnThree">{{ products.p2[name] }}</td>
              </template>
            </template>
          </tr>          
        </template>
        
      </tbody>
    </table>
    <div v-else>
      <p>Product comparison is not available at this time.</p>
    </div>`,
    methods: {
        clean(input) {
            return (input) ? input.replace(/[^0-9a-zA-Z\-\,\:\/]+/g, '') : "";
        },
        formatParamValues(input) {
            return (input) ? "%7B%22value%22%3A%22" + input.replaceAll(",", "%22%7D%2C%7B%22value%22%3A%22") + "%22%7D" : "";
        },
        formatResponse(res) {
            // Clean up data format to make it easier to work with
            // by trimming off the "data" : {} level of the object
            // and remove other fields not being used by the table
            let response = res;

            if (response && response.data) {

                var key = Object.keys(response.data)[0];
                response = response.data[key].items;

                // Get list of rows to display
                const elementsAllowed = this.getElementNames();
                if (elementsAllowed) {
                    // Declare variable to return
                    let outputArray = [];
                    // Loop through object and reduce to only the matching keys
                    for (const item of response) {
                        const filtered = Object.keys(item)
                            .filter(key => elementsAllowed.includes(key))
                            .reduce((obj, key) => {
                                return Object.assign(obj, {
                                    [key]: item[key]
                                });
                            }, {});
                        // Push filtered object to array
                        outputArray.push(filtered);
                    }
                    response = outputArray;
                }
            }
            return response;
        },
        setProduct(newProduct) {
            let indexPosition = 0;
            // Return early if product not valid
            if (!newProduct && newProduct?.baseProduct.name !== null) { return false; }
            //remove nbsp in title
            newProduct.baseProduct.name.html = newProduct.baseProduct.name.html.replace(/&nbsp;/g, ' ');
            // Find product position to assign next
            while (this.products.hasOwnProperty("p" + indexPosition) && indexPosition < this.productMax) {
                let thisProductId = this.products["p" + indexPosition]?.baseProduct.fragmentId;
                let newProductId = newProduct?.baseProduct.fragmentId;
                // Return early if not null/empty and values are the same.
                if (thisProductId && newProductId && (thisProductId === newProductId)) { return false; }
                indexPosition = indexPosition + 1;
            }
            // Assign Product
            if (indexPosition < this.productMax) {
                this.products["p" + indexPosition] = newProduct;
            }
            return true;
        },
        assignProductsByPaths(productArray) {
            const paths = this.query.parameterValues.substring(1).split(",");
            for (const path of paths) {
                let product = productArray.find(obj => obj?._path === path);
                this.setProduct(product);
            }
            this.appendParameter();
        },
        assignProductList(productArray) {
            // Assigns Parameters. Returns true if parameters were assigned
            this.assignProductsByID(productArray, this.getParameterProducts());
            // Assigns Product IDs.
            if (this.productIds) {
                let productIds = this.productIds.split(",");
                this.assignProductsByID(productArray, productIds);
            }
            // Set Other Products
            for (const newProduct of productArray) {
                this.setProduct(newProduct);
            }
        },
        buildProductsObject(productArray) {
            //assign products by path or list
            if (this.query.parameterName === "path") {
                this.assignProductsByPaths(productArray);
            } else {
                this.assignProductList(productArray);
            }

            // Check if at least two products exist
            if (this.products.p0 && this.products.p1) {
                this.products.valid = true;
            }
            // Check if third index position product exists
            if (this.products.p2) {
                // Valid for three column layout
                this.products.col3 = true;
            }
             this.$nextTick(() => {
                 window.CQ.disclosure.build();
             });
        },
        async fetchProducts() {
            try {
                const res = await fetch(this.url);
                if (!res.ok) {
                    const message = `An error has occured: ${res.status} - ${res.statusText}`;
                    throw new Error(message);
                }
                const data = await res.json();
                this.products.all = this.formatResponse(data);
                this.buildProductsObject(this.products.all);
            }
            catch (err) {
                this.products.all = err.message;
            }
        },
        isLink: function (input) {
            return (input && (input.startsWith("/content/") || input.startsWith("http"))) ? true : false;
        },
        setDimensions: function ({ width }) {
            this.width = width;
        },
        checkForHash: function (input) {
            let id = input;
            if (!id.includes("#")) {
                id = "#" + input;
            }
            return id;
        },
        getParameterProducts: function () {
            let parameters = new URLSearchParams(document.location.search);
            let parameterCompare = parameters.get("compare");
            if (parameterCompare) {
                // Clean it and create unique Array
                parameterCompare = this.clean(decodeURI(parameterCompare));
                parameterCompare = parameterCompare.split(",");
                parameterCompare = [...new Set(parameterCompare)];
            }
            return parameterCompare;
        },
        assignProductsByID: function (productArray, productIDList) {
            if (productIDList) {
                for (const productID of productIDList) {
                    let product = productArray.find(obj => obj?.baseProduct.fragmentId === productID);
                    this.setProduct(product);
                }
                return true;
            }
            return false;
        },
        getFragmentIdList: function () {
            let fragmentIdArray = [];
            let fragmentIdString = "";
            for (const product of this.products.all) {
                if (product) {
                    fragmentIdArray.push(product.baseProduct.fragmentId);
                }
            }
            if (fragmentIdArray.length > 1) {
                fragmentIdString = fragmentIdArray.join();
            }
            return fragmentIdString;
        },
        getElementNames: function () {
            if (!this.elementNames) { return }
            // Add default baseProduct object to array
            let outputArray = ["baseProduct", "_path"];
            // Get element names from applicaiton
            const elementNamesArray = this.elementNames.split(",");
            // Add element and element title to the array of keys
            for (const elementName of elementNamesArray) {
                outputArray.push(elementName + "Title");
                outputArray.push(elementName);
            }
            // Return unique values
            return [...new Set(outputArray)];
        },
        appendParameter: async function () {
            if (this.linkId) {
                let id = this.checkForHash(this.linkId);
                let element = await this.waitForElement(id);
                let parameterValue = this.getFragmentIdList();
                let parameterName = "compare";

                if (parameterValue) {
                    parameterValue = encodeURIComponent(parameterValue);
                    let href = (element) ? element.getAttribute("href") : "";
                    if (href) {
                        let separator = (href.includes("?")) ? "&" : "?";
                        href = href + separator + parameterName + "=" + parameterValue
                        element.setAttribute("href", href);
                    }
                }
            }
        },
        waitForElement: function (selector) {
            return new Promise(resolve => {
                if (document.getElementById(selector)) {
                    return resolve(document.getElementById(selector));
                }
                const observer = new MutationObserver(mutations => {
                    if (document.querySelector(selector)) {
                        resolve(document.querySelector(selector));
                        observer.disconnect();
                    }
                });
                observer.observe(document.body, {
                    childList: true,
                    subtree: true
                });
            });
        }
    },
    data() {
        return {
            query: {
                protocol: document.location.protocol,
                host: document.location.host,
                path: "graphql/execute.json/dot-pnc-aem-caas",
                name: this.clean(this.queryTitle),
                parameterName: this.clean(this.paramName),
                parameterValues: this.clean(this.paramValues)
            },
            products: {
                all: null,
                col3: false,
                valid: false
            },
            width: document.documentElement.clientWidth,
        }
    },
    computed: {
        activeModel: function () {
            return ((this.query.name).includes("personal-credit-card")
                    || (this.query.name).includes("tm-credit-card") 
                    || (this.query.name).includes("business-credit-card") 
                    || (this.query.name).includes("student-lending-options") 
                    || (this.query.name).includes("virtual-wallet")
                    || (this.query.name).includes("savings")) ? true : false;
        },
        url: function () {
            let thisUrl = this.query.protocol + "//" + this.query.host + "/" + this.query.path + "/" + this.query.name;
            if (this.query.parameterName) {
                thisUrl += "%3B" + this.query.parameterName + "%3D{\"_logOp\"%3A\"OR\"%2C\"_expressions\"%3A[" + this.formatParamValues(this.query.parameterValues) + "]}";
            }
            return thisUrl;
        },
        desktopFormat: function () {
            return (this.width > 991.9) ? true : false;
        },
        hasColumnThree: function () {
            return (this.products.col3 && this.desktopFormat)
        },
        columnClass: function () {
            let colClassName = 'cmp-comparison-col--2';
            if (this.hasColumnThree) {
                colClassName = 'cmp-comparison-col--3';
            }
            return colClassName;
        },
        showProductMenu: function () {
            return ((this.products.all.length > 3) || (this.products.all.length === 3 && !this.hasColumnThree))
        }
    },
    created() {
        this.fetchProducts();
    },
    updated() {
        if(window.CQ.utilGlobal) { window.CQ.utilGlobal.accessibleLinks(); }
    }
});

app.mount('#appComparison');